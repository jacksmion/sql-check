一个源码 SQL 慢查询巡检工具
一、 核心功能需求
1. SQL 提取模块 (The Miner)
静态字符串提取：自动扫描代码中的常量字符串，识别以 SELECT、UPDATE、DELETE、INSERT 开头的文本。

多语言支持：
Go、python、C++

通用：支持通过正则表达式扫描其他语言的文件。

位置追踪：提取 SQL 的同时，必须记录其所属的文件路径和行号，以便后续定位。

2. 环境上下文接入 (Schema Awareness)
DDL 加载：支持读取本地 schema.sql 文件，获取表名、字段名及索引信息。


3. 核心审计引擎 (The Auditor)
SQL 解析：使用 tidb/parser 将 SQL 文本转为 AST（抽象语法树）。

规则匹配：根据 AST 分析 SQL 逻辑。

风险定级：将问题分为“致命（无索引删除）”、“警告（潜在慢查询）”、“建议（规范问题）”。

4. 报告输出 (Reporter)
终端输出：支持类似编译器的错误格式（file:line: message），方便集成。

交互式报告：生成 HTML 或 Markdown 格式的详细报告。

二、 技术架构建议
建议采用 “插件化” 架构，将提取、解析、审计解耦：

Scanner (扫描层)：遍历文件系统，过滤文件后缀。采用并发 Worker Pool 模式，利用多核 CPU 加速文件读取与处理。

Extractor (提取层)：针对不同语言实现提取器。

Parser & Binder (解析绑定层)：利用 tidb/parser 解析 SQL，并将其与加载的 Schema 信息（索引、数据量级）进行关联。

Rules Engine (规则引擎)：运行具体的审计算法。

三、 重点审计规则 (你的工具价值所在)
这是工具最核心的“灵魂”，你可以先实现以下几类高频痛点规则：

1. 索引缺失类
WHERE 字段无索引：最基础的慢查询原因。

最左前缀违规：如果表有联合索引 (a, b)，代码中只写了 WHERE b = 1。

隐式类型转换：例如字符串字段 phone，SQL 写成 WHERE phone = 138... (无引号)，导致索引失效。

2. 性能隐患类
全表扫描风险：UPDATE 或 DELETE 语句完全没有 WHERE 条件。

深分页问题：检测 LIMIT 100000, 10 这种大偏移量的分页。

Select *：在大表查询中，提醒改为按需取字段，减少 IO。

负向查询：检测 !=、NOT IN 或模糊查询开头使用通配符（LIKE '%abc'）。

4. 性能要求
并发处理：在文件扫描和 SQL 提取阶段，必须采用并发模型（Go Routines）以支持大规模代码仓库的快速扫描。


技术栈：Golang

推荐的开发路径（MVP 版本）
按照以下步骤实现最小可行性产品：

实现一个简单的解析器：给定一个包含 SQL 的文本文件，能利用 tidb/parser 识别出表名和 WHERE 字段。

实现 DDL 导入：读取一个 schema.sql 文件，在内存中构建一个“表结构索引地图”。

编写审计规则：先写最简单的规则——“检查 WHERE 字段是否在索引地图里”。

封装为 CLI：让用户可以运行 sql-check --schema=./db.sql --dir=./src。